> 感觉好多讲状压DP的博客都有点乱，结合各路大佬的博客，加上我自己的理解（过往的做的题）同时学习一下蒟蒻桑的博客，总结出一篇博客来，供初学者参考

## 【前言】

状压DP 是动态规划的一种通过将状态压缩为整数来达到优化转移的目的的动态规划方法。在进行状压DP的时候，我们要把所有的压缩状态都看成是 $01$​​ 串，不管是 $(23333)_{10}$​ 还是 $(114514)_{10}$ 我们都要把它们变成二进制来处理。所以要学习状压DP，我们肯定绕不开位运算来便利我们二进制的运算。下面就让我们一同来复习一下位运算吧。

## 【位运算】

位运算这块在平常的程序当中用的比较少，下面我们就以 `C++` 为例，带同学们复习一下一些常用的位运算符号吧。

- `<<` 左移：整个 01 串左移一位，右边补 0，会丢弃最高位信息。
- `>>` 右移：整个 01 串右移一位，左边补符号位(在补码意义下)，会丢弃最低位信息。
- `|` 或：同为 0 时才为 0；
- `&` 与：同为 1 时才为 1；
- `^` 异或：相同为 0，不同为 1，所以对于一位二进制的 x，我们可以用`x ^ 1` 将 x 取反；
- `~`取反：0 变成 1，1 变成 0。

具体到应用上，对于一位二进制数 x：

- 去掉最后一位：`x >> 1`；
- 在最后加一个 0：`x << 1`；
- 在最后加一个 1：`(x << 1) | 1`；
- 把最后一位变成 1：`x | 1`；
- 把最后一位变成 0：`(x | 1) - 1` 或 `(x >> 1) << 1` 或 `x & 0xFFFFFFFE`；
- 最后一位取反：`x^1`；
- 把右数第 k 位变成 1：`x | (1 << (k - 1))`；
- 把右数第 k 位变成 0：`x & (~(1 << (k - 1)))`；
- 把右数第 k 位取反：`x ^ (1 << (k - 1))`；
- 取末 k 位：`x & ((1 << k) - 1)`；
- 取右数第 k 位：`(x >> (k - 1)) & 1`；
- 把末 k 位变成 1：`x | ((1 << k) - 1)`；
- 把末 k 位取反：`x ^ ((1 << k) - 1)`；
- 把右边连续的 1 变成 0：`x & (x + 1)`；
- 把右起的第一个 0 变成 1：`x | (x + 1)`；
- 把右边连续的 0 变成 1：`x | (x - 1)`；
- 取右边连续的 1：`(x ^ (x + 1)) >> 1`；
- 去掉右起的第一个 1 的左边：`x & (-x)`（$lowbit$）。

这边友情提示一下，位运算的优先级很复杂，为了方便起见，一定记得**加上括号**！！！

## 【经典例题】

### 互不攻击的车

<details open="" class="warn">
<summary> Description </summary> 
<p>在 $n*n(n\le 20)$ 的方格棋盘上放置 $n$ 个车（可以攻击所在的行、列），求使它们不能互相攻击的方案数。
</p>
</details><br>

这道题作为引入非常简单，我们一行一行放置，则第一行有 $n$​ 种放置的选择，第二行有 $n−1$​ 种放置的选择，……，最后一行只有 $1$ 种放置的选择。根据我们的乘法原理，我们的答案就是 $n!$​​

---

$$
QAQ
$$

---

那这道题和我们的状压DP有什么关系呢，别急看我对这道题做一点点变换。

<details open="" class="warn">
<summary> Description </summary> 
<p>在 $n*n(n\le 20)$ 的方格棋盘上放置 $n$ 个车（可以攻击所在的行、列），某些格子有障碍不能放车，求使它们不能互相攻击的方案数。
</p>
</details><br>

这时就不能简单的排列组合了，数学的方法就得上容斥了，非常麻烦。所以我们来看看状压 DP 的方法。

因为我们知道这个车是需要一行一行放的，在放第 $i$​ 行的时候，我们只关系哪些列已经被之前的车占据了

* 在放第 $i$​ 行的时候，我们只关系哪些列已经被之前的车占据了，而不会去关心具体每一列由哪一行的车占据。所以我们可以用车占据列的情况作为状态，我们设某一列如果已经放了车则置为 $1$，否则置为 $0$。

  这样一个状态就可以用一个最多 $20$ 位的二进制数来表示。例如 $n=5$，第 $1,3,4$ 列已经放置了车，则这个状态就可以表示为 $01101$（从右到左）。

那么我们令 $f[i][st]$​​​ 表示前 $i$ 行状态为 $st$ 的方案数，那么就有 $f[i][st]=∑f[i−1][st^′]$ ，其中 $st^′$ 是前继状态，也就是我们在第 $i$ 行第 $j$ 列放车，此时满足第 $i$ 行第 $j$​ 列不是障碍点，

并且 $(st^′\& (1<<(j−1)))==0$ 和 $st^′+(1<<(j−1))==st$  。

记住我们一定要把状态看成 $01$ 串！

举个例子，$f[3][01101]=f[2][00101]+f[2][01001]+f[3][01100]$ 。

【AC Code】

```cpp
const int N = 100001;
int n, m;
ll fac[N], a[N];
ll f[1 << 22] = {1}; // 注意 long long，忘记加搞的找半天bug
inline int lowbit(int x) {return x & (-x);}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    fac[0] = 1;
    for (int i = 1; i <= 20; ++i) fac[i] = fac[i - 1] * 2;
    cin >> n >> m;
    for (int i = 1, x, y; i <= m; ++i) {
        cin >> x >> y;
        a[x] += fac[y - 1];
    }
    for (int i = 1; i <= (1 << 20) - 1; ++i) {
        int c = 0;
        for (int j = i; j > 0; j -= lowbit(j)) c += 1;
        for (int j = i & (~a[c]); j > 0; j -= lowbit(j))
            f[i] += f[i ^ lowbit(j)];
    }
    cout << f[fac[n] - 1];
}

// 4 2
// 1 1
// 2 2
// 14
```

### 互不侵犯

之前单独写过题解：[Here](https://www.cnblogs.com/RioTian/p/13600054.html)

<details open="" class="warn">
<summary> Description </summary> 
<p>在 $n*n(1\le n \le 9)$ 的棋盘里放 $k (0\le k\le n)$ 个国王，使得它们互不攻击，共有多少种排放方案<br>
国王可以攻击她的上下左右，以及左上左下右上右下的 $8$ 个格子
</p>
</details><br>

对于 $n$​ 不大的情况我们可以采取搜索来做，但格子数量一旦多起来会 $TLE$​​。然后我们考虑一般的动态规划，我们一个一个格子拓展，好像也很难设计出无后效性的转移方案，所以我们还是考虑放国王的过程。

* 由于一行可以放很多国王，所以一个个放国王的话就不太好写了。我们考虑一行一行放置。

* 这时我们对 $i$ 行，能放几个国王、以及放哪都和前一行国王位置相关联，所以只需要要关西上一行国王的放置位置。

  那么我们如何表示每一行的状态呢？没错还是 $01$ 串。

* 由于每一行的格子小于等于 $9$ 个，每一个格子又只有两种状态：放和不放国王，

  假设我们把放国王的记为 $1$，没有放国王的记为 $0$，很显然每一行的状态就是一个 $01$ 串，如果我们把这个串看成一个二进制数，那这个数就会小于等于 $2^9−1$。

* 那么我们就可以拿一个 `int` 类型来表示每一行的状态。那怎么样的状态才是合法的呢？很简单，不能有两个相邻的国王也就是不能有两个相邻的 $1$ 就行了。

  那怎么判断呢，其实也不难，只要 $(x \& (x << 1)) == 0$ 就可以了。

* 那剩下就是我们枚举上一行的状态是 $x$ ，当前行的状态是 $y$ ，那当这两行的国王不会互相攻击也就是 $(x \& y) == 0$ 并且 $(x \& (y << 1)) == 0$ 并且 $(x \& (y >> 1) == 0)$ 三个条件都满足就可以了

具体到代码上，我们设 $f[i][j][k]$​ 表示第 $i$ 行的状态为 $k$ 且已经放了 $j$ 个国王的方案数。

接下来我们考虑怎么转移，其实就和我们上面讨论的一样

* $f[i][j][k] += f[i - 1][j - num[k]][p]$ ，其中 $(k\&p) == 0$ 并且 $(k\&(p<<1))==0$ 并且 $k\&(p >> 1) == 0$ 并且 $k,p$ 均合法，$num[k]$ 表示 $k$ 这个状态中 $1$ 的数量（国王数）。

【AC Code】

```cpp
int n, k;
ll f[10][1 << 10][82], ans;
//f数组表示的就是在总共x行的xx状态下放置xxx个国王一共有几种方式
int C(int st) { // Count st在二进制下多少个 1
    int cnt = 0;
    while (st) {if (st & 1) cnt += 1; st /= 2;}
    // return __builtin_popcount(st);
    return cnt;
}
bool check1(int st) {
    // 判断单行状态st是否合法
    for (int i = 0; i + 1 < n; ++i) //判断i和i的上一位
        //左移i判断第i位上是否为1，即已经放置了国王
        if (st & (1 << i) and (st & (1 << (i + 1))))
            return false;
    return true;
}
bool check2(int st, int st2) {
    // 判断当前行状态st和上一行状态st2是否合法
    for (int i = 0; i < n; ++i) {
        if (st & (1 << i)) {
            if (st2 & (1 << i)) return false;
            else if (i + 1 < n and (st2 & (1 << (i + 1)))) return false;
            else if (i - 1 < n and (st2 & (1 << (i - 1)))) return false;
        }
    }
    return true;
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cin >> n >> k;
    for (int i = 0; i < n; ++i)
        for (int st = 0; st < (1 << n); ++st) {
            if (!check1(st)) continue;
            if (i == 0) f[i][st][C(st)] = 1;
            else {
                //控制国王总数不超过k，j表示现在有几个国王
                for (int j = C(st); j <= k; ++j)
                    for (int st2 = 0; st2 < (1 << n); ++st2) {
                        if (!check1(st) || !check2(st, st2)) continue;
                        f[i][st][j] += f[i - 1][st2][j - C(st)];
                    }
            }
        }

    for (int st = 0; st < (1 << n); ++st) ans += f[n - 1][st][k];
    cout << ans << "\n";
}
```

另外这道题还可以预处理然后再进行枚举，详情见：[Here](https://www.cnblogs.com/RioTian/p/13600054.html)

### 炮兵阵地

在《算法进阶指南》0x56 写过题解：[Here](https://www.cnblogs.com/RioTian/p/13522441.html)

原题链接：[Here](https://ac.nowcoder.com/acm/problem/16886?&headNav=acm)

<details open="" class="warn">
<summary> Description </summary> 
<p>司令部的将军们打算在$N*M(N \le 100, M \le 10)$​ 的网格地图上部署他们的炮兵部队。一个的网格地图上部署他们的炮兵部队。一个 $N*M$ 的地图由的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用列组成，地图的每一格可能是山地（用"$H$表示），也可能是平原（用"$P$​"表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如下图中黑色区域所示：<br>
如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。<br>
现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。
</p>
</details><br>

<img src="https://uploadfiles.nowcoder.com/images/20180701/305473_1530454615753_58BC0148FDF4BE2D4D3EDC671AD479A2" style="zoom: 80%;" />

这道题可以看成是上一道题的升级版，思路和上一题是比较类似的。我们还是沿用之前的思路，我们一行一行地去放炮兵部队。由于每一个炮可以打到两行，所以每一行的放置方法都和前两行的放置情况有关。

* 所以我们设 $f[i][j][k]$ 表示第 $i$ 行的状态为 $j$，第 $i−1$ 行的状态为 $k$ 时所用的最大炮兵数。

我们接下来考虑如何转移

* 其实当转移到第 $i$ 行时，我们要枚举第 $i$ 行的状态 $j$，第 $i−1$ 行的状态 $p$，第 $i−2$ 行的状态 $q$，则当 $j,p,q$ 均不互相发生冲突，且 $j,p,q$ 均是合法状态时，我们有 $f[i][j][p]=max(f[i][j][p],f[i−1][p][q]+num[j])$ 。其中说 $j,p,q$ 均是合法状态是说任意一个 $1$ 的左右两遍两位都不能是 $1$. 比如对于 $j$ ，我们要求 $((j \&(j >> 1)) == 0)\ and\ ((j \&(j >> 2))==0)$  ，并且为 $1$ 的地方都是平原（也可用位运算判断）。比如 $010100$ 是不合法的，但是 $010001$ 是合法的。

> 但是如果我们枚举 $j,p,q$ 均从 $00000……0$ 枚举到 $11111……1$​，是会超时的。
>
> 所以我们先预处理出合法的 $01$ 串的数量，也就是任意一个 $1$ 的左右两遍两位都不能是 $1$ 的串数量，处理下来的数量在 $100$ 以内，这样我们只要每次枚举合法的状态再去判冲突就可以了。然后在开数组的时候我们 $f[i][j][k]$ 表示第 $i$ 行的状态为第 $j$ 个合法状态，第 $i−1$ 行的状态为第 $k$​ 个合法状态时所用的最大炮兵数即：$f_{i,j,k} = \max(f_{i-1,k,z})$​，这样我们的空间也降下来了。

先预处理一行放置炮兵的所有情况,用二进制保存状态,当 $m=10$ 时,合法的只有 $60$ 种状态。

记 $f_{i,j,k}$ 为第 $i$ 行为 $j$ 状态，$i-1$ 行为 $k$​ 状态的最大放置数

$f_{i,j,k} = \max(f_{i,k,z})$

转移时需要判断每行放置炮兵的位置是否有山以及 $x,y,z$​ 是否两两合法。

同样用二进制保存山的状态,存在山的位置为 $1$ ,显然当两个状态按位与的值非 $0$ 时,这两个状态不能共存。

【代码实现】

```cpp
const int N = 110;
int n, m;
int f[N][N * 10][N * 10], tot[N * 10], st[N * 10];
set<int>s;
void chmin(int &a, int b) { return (void)(a > b ? a = b : a = a); }
void chmax(int &a, int b) { return (void)(a < b ? a = b : a = a); }
void dfs(int pos, int t, int d) {
    s.insert(t);
    tot[t] = d;
    for (int i = pos + 3; i < m; ++i) dfs(i, t | (1 << i), d + 1);
}
bool check(int i, int j, int a, int b) {
    if (j <= 0) return 1;
    if (a & st[i] || b & st[j] || a & b) return 0;
    return 1;
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) for (int j = 0; j < m; ++j) {
            char c; cin >> c;
            if (c == 'H') st[i] |= 1 << j;
        }
    dfs(-3, 0, 0);
    for (int i = 1; i <= n; ++i) {
        for (auto x : s) for (auto y : s) {
                if (!check(i, i - 1, x, y)) continue;
                for (auto z : s)
                    if (check(i, i - 2, x, z) and check(i - 1, i - 2, y, z))
                        chmax(f[i][x][y], f[i - 1][y][z] + tot[x]);
            }
    }
    int ans = 0;
    for (auto x : s) for (auto y : s)
            chmax(ans, f[n][x][y]);
    cout << ans << "\n";
}
```

### TSP问题 

$TSP$ 问题详细介绍：[Here](https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98)

<details open="" class="warn">
<summary> Description </summary> 
<p>旅行商问题（$travelling salesman problem  ，TSP $）又译为旅行推销员问题、担货郎问题，简称为 $TSP$ 问题。<br>
给你一张图（也可以是由若干点和边组成的抽象图），求从某个起点出发，经过且只经过一遍所有点的最短路径。
</p>
</details><br>

最简单的方法肯定是 $n!$ 的暴力，我们枚举出每个点到达的顺序然后计算和更新答案。我们下面如何考虑用状压 DP 的方式来解答。

我们设 $f[st][i]$​ 表示当前状态是 $st$​，最后到达的一个点是 $i$​ 时，所经过的最短距离。其中 $st$​ 时一个 $01$​ 串，表示走过点的信息。比如 $10110$​ 从右往左看，代表的就是 $2,3,5$ 号点已经走过但 $1,4$ 号点还没有走过的状态。我们能够用这样的状态来表示是因为，假如对于状态 $f[10110][3]$，也就是我们走过了 $2,3,5$ 号点，现在位于 $3$ 号点所经过的最短距离。我们其实只关心之前到达过 $2,5$ 号点，但其实不必关心具体的到达顺序时怎么样的。我们最后的答案就是

$\min(f[11……1][1],f[11……1][2],……,f[11……1][n])$​

下面我们考虑如何转移，其实很简单

* 就是 $f[st][i] = \min(f[st^‘][j] + a[j][i])$ ，

  其中 $st′+(1<<(j−1))==st$  并且 $st^′\&(1<<(j−1))==0$，也就是 $st^′$ 刚好比 $st$ 在第 $j$ 位少了一个 $1$。

* 我们举一反三，其实如果要求每个点恰好到达两次，那就用三进制就好了；同理如果每个点要恰好到达 $k$​ 次，那我们就用 $k+1$ 进制来表示状态就好了。 当然我们一般会向上取整到 $2^x$ 进制，因为这样就是若干位 $2$ 进制，可以使用位运算来让我们整体的运算更加丝滑。

> 我们扩展一下，如果要求走完所有点回到原点怎么办。
>
> 由于是一个环，所以从哪个点出发其实都是一样的，我们不妨从一号点出发，
>
> 先求出 $f[11……1][2],f[11……1][3],……,f[11……1][n]$​，然后我们最后的答案就是
>
> $\min(f[11……1][2] + a[2][1],f[11……1][3] + a[3][1],……,f[11……1][n] + a[n][1])$

---

$$
QAQ
$$

---

这里给出两道 TSP 问题题目并给出其代码实现。

[NowCoder - 郊区春游](https://ac.nowcoder.com/acm/problem/16122) 和 [NowCoder - 简单环](https://ac.nowcoder.com/acm/problem/16544)

【郊区春游 AC Code】

一开始就在旅游的几个点选一个作为起点，然后这个点就算游过了，游完别的景点在最后一个景点停下即可。

用 $f[i][j]$，$i$ 表示状态（哪些点游过，哪些点没有），$j$ 表示最后停留在哪个点。

```cpp
const int N = 210, inf = 0x3f3f3f3f;
int rs[18]; // 表示必须要旅游的点
int e[N][N], f[34000][20];
int n, m, r;
void chmin(int &a, int b) { return (void)(a > b ? a = b : a = a); }
void floyd() {
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                chmin(e[i][j], e[i][k] + e[k][j]);
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cin >> n >> m >> r;
    for (int i = 1; i <= r; ++i) cin >> rs[i];
    memset(e, inf, sizeof(e));
    memset(f, inf, sizeof(f));
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u][v] = e[v][u] = w;
    }
    floyd();
    for (int i = 1; i <= r; ++i) f[1 << (i - 1)][i] = 0; ; //最开始走的那一个点，是没有花费的
    int len = (1 << r) - 1;
    for (int i = 1; i < len; ++i) //枚举状态
        for (int j = 1; j <= r; ++j) { //枚举起始位置
            int jj = 1 << (j - 1);
            if (!(i & jj)) continue; //起始位置肯定是走过的
            for (int k = 1; k <= r; ++k) { //枚举终止位置
                int kk = 1 << (k - 1);
                if (i & kk) continue; //终止位置一定是一个新位置
                chmin(f[i | kk][k], f[i][j] + e[rs[j]][rs[k]]);
            }
        }
    int ans = inf;
    for (int i = 1; i <= r; ++i) chmin(ans, f[len][i]);
    cout << ans;
}
```

【简单环AC Code】

前面部分跟“郊区春游”差不多，属于TSP问题、也是枚举起点、终点（终点这里得比起点大，避免重复统计），进行状态转移，不同的是这里的 $f$​ 数组记录的是方案数量，然后每次转移以后要判终点和起点是否可以相连，相连就进行统计。

最后答案要除以 $2$ ，原因是大于等于 $3$ 的回路可能会顺时针走一遍、逆时针走一遍（本题只统计大于等于 $3$ 的就是这个原因）。
除以 $2$  用逆元来解决在模意义下的除法。

```cpp
#define ll long long
#define lowbit(x) x&(-x)
const ll mod = 998244353;
int lowpoint(int x) {
    int ans = 1;
    while (!(x & 1)) {
        x >>= 1;
        ans++;
    }
    return ans;
}
int n, m, K;
const int N = 22;
int mp[N][N];
ll ans[N];
ll dp[1 << 22][22];
int main() {
    scanf("%d%d%d", &n, &m, &K);
    while (m--) {
        int u, v;
        scanf("%d%d", &u, &v);
        mp[u][v] = mp[v][u] = true;
    }
    for (int i = 1; i <= n; i++) { //枚举那些边是起点
        dp[1 << (i - 1)][i] = 1;
    }
    int len = (1 << n) - 1; //最后一个状态，即所有点都走过
    for (int i = 1; i <= len; i++) {
        int s;
        for (int j = 1; j <= n; j++)
            if ((i >> (j - 1)) & 1) {
                s = j;
                break;
            }
        for (int j = 1; j <= n; j++) { //枚举起点
            int jj = 1 << (j - 1);
            if (!(i & jj)) continue;
            for (int k = s + 1; k <= n; k++) { //枚举终点
                int kk = 1 << (k - 1);
                if (i & kk) continue;
                if (mp[j][k]) {
                    dp[i | kk][k] = (dp[i | kk][k] + dp[i][j]) % mod;
                }
            }
            if (mp[j][s]) {
                int len = __builtin_popcount(i);
                if (len >= 3)
                    ans[len % K] = (ans[len % K] + dp[i][j]) % mod;
            }
        }
    }
    for (int i = 0; i < K; i++)
        printf("%lld\n", (ans[i] * (mod + 1) / 2) % mod);
}
```

